### 概要
&emsp;&emsp;本文主要讨论堆的基础知识，以及Leetcode相关题目的解题思路

### 什么是堆(优先队列)
&emsp;&emsp;堆是一个完全二叉树(除了最底层以外，其他每一层都是满的)，因此堆可以用数组表示，普通二叉树通常用链表表示。堆用数组表示如下图：

![](http://bubkoo.qiniudn.com/heap-and-array.png)

&emsp;&emsp;对于下标为i的节点，可以很容易计算出该节点的父节点、子节点的下标:
- Parent(i) = floor(i/2)
- LeftChild(i) = 2*i
- RightChild(i) = 2*i +

![](http://bubkoo.qiniudn.com/heap-and-array-parent-children.png)

&emsp;&emsp;堆一般分为大根堆和小根堆
- 大根堆
  - 大根堆的最大值都出现在根节点
  - 堆中每个父节点的值都大于子节点值

&emsp;&emsp;![](http://bubkoo.qiniudn.com/max-heap.png)

- 小根堆
  - 小根堆的最小值都出现在根节点
  - 堆中每个父节点的值都小于子节点值

&emsp;&emsp;![](http://bubkoo.qiniudn.com/min-heap.png)

### 堆排序
&emsp;&emsp;每次取出堆顶的数(最大/最小)取出，再将剩余的节点调整成大根堆/小根堆，对排序定义了一下几种操作:
- 大/小根堆调整
- 创建最大堆
- 堆排序

&emsp;&emsp;下面以大根堆为例，说明堆排序的三个过程: 最大堆调整 (MAX-HEAPIFY) 是保证大根堆的性质，是创建大根堆的核心子程序(递归调用)。

![](http://bubkoo.qiniudn.com/MAX%E2%80%90HEAPIFY-Procedure.png)

&emsp;&emsp;创建大根堆只需递归调用最大堆调整即可

![](http://bubkoo.qiniudn.com/building-a-heap.png)

&emsp;&emsp;堆排序

![](http://bubkoo.qiniudn.com/HeapSort.png)

堆排序动画演示:

&emsp;&emsp;![](http://bubkoo.qiniudn.com/Sorting_heapsort_anim.gif)

### 时间复杂度

### 参考资料
[1] http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/
